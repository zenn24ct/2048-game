<!doctype html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>2048</title>
    <style>
        :root {
            --bg: #f6f6f6;
            /* bgとはbackgroundの略 */
            --board: #e9e9e9;
            /* boardとはゲーム盤のこと */
            --cell: #ffffff;
            /* cellとはマス目のこと */
            --accent: #222;
            /* accentとは強調色のこと */
        }

        html,
        body {
            height: 100%;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center
        }

        .app {
            width: 340px;
            max-width: 94vw;
            background: white
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        .score {
            font-weight: 700
        }

        /* （変更ポイント） board の列定義を「縮められる1fr」に */
        .board {
            width: 320px;
            height: 320px;
            background: var(--board);
            padding: 12px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            /* 1frは利用可能なスペースを均等に分割する単位 */
            gap: 12px;
            /* マス目の間隔 */
            box-sizing: border-box;
            user-select: none;
        }

        /* cell を縮められるようにする*/
        .cell {
            background: var(--cell);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 20px;
            min-height: 64px;
            min-width: 0;
            overflow: hidden;
            /* 余剰テキストをはみ出させない */
        }

        /* tile をセル幅にピッタリ収める */
        .tile {
            width: 100%;
            box-sizing: border-box;
            padding: 20px 10px;
            /* paddingとは、要素の内側の余白のこと */
            border-radius: 6px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }


        .v-2 {
            background: #fff876;
        }

        .v-4 {
            background: #d5ff99
        }

        .v-8 {
            background: #5ddd01
        }

        .v-16 {
            background: #55eafe
        }

        .v-32 {
            background: #385cff
        }

        .v-64 {
            background: #c459ff
        }

        .v-128 {
            background: #ff5ec4
        }

        .v-256 {
            background: #ff7b59
        }

        .v-512 {
            background: #ffb259
        }

        .v-1024 {
            background: #ff5972
        }

        .v-2048 {
            background: #ff5959
        }

        /* コントロールボタン */
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 10px
        }

        button {
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            background: rgb(252, 187, 255)
        }

        /* @mediaとは、画面の幅に応じてスタイルを変えるためのルール */
        @media (max-width:420px) {
            .board {
                width: 92vw;
                height: 92vw;

            }

            .cell {
                min-height: unset;
                padding: 6px
            }
        }
    </style>
</head>

<body>
    <div class="app" role="application" aria-label="2048ゲーム">
        <header>
            <h1>2048</h1>
            <div>
                <div class="score">Score: <span id="score">0</span></div>
                <div style="font-size:12px;color:#000000">Best: <span id="best">0</span></div>
            </div>
        </header>

        <div id="board" class="board" aria-label="ゲーム盤"></div>

        <div class="controls">
            <button id="btnNew">New Game</button>

        </div>
    </div>

    <script>
        /* --- 状態 --- */
        const SIZE = 4; /* 4x4の盤面 */
        let grid = createEmpty(); /* ゲーム盤の状態を保持する2次元配列 */
        let score = 0;
        let best = Number(localStorage.getItem('2048_best') || 0);

        const boardEl = document.getElementById('board');
        /* getElementById('board')でboard要素を取得 以下は同じ*/
        const scoreEl = document.getElementById('score');
        const bestEl = document.getElementById('best');
        bestEl.textContent = best; /* bestスコアを表示 */

        /* --- ユーティリティ --- */
        /* function は、関数を定義するところ */
        function createEmpty() {
            /* ここでは、SIZE x SIZE の2次元配列を作成し、すべての要素を0で初期化して返す 
            理由：2048ゲームでは、空のセルを0で表現するため
            */
            return Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
        }

        /* ここでは、2次元配列をコピーする関数を定義。
        理由は、グリッドの状態を変更する前に元の状態を保持するため */
        function copyGrid(g) { return g.map(row => row.slice()) }

        /* ランダムな位置に2か4のタイルを追加する関数*/
        function addRandomTile(g) {
            const empties = []; // 空のセルの位置を格納する配列

            /* rは行、cは列
            空のセルの位置を検索して、0があったらempties配列に追加する
            空セル（値が 0）を列挙し、ランダムに1つ選んで2か4を配置する
            返り値は置いた位置（{r,c}）か、空きが無ければ false。
            使い所：新しい手が終わった後に addRandomTile(grid) を呼び出す
             */
            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) if (g[r][c] === 0) empties.push([r, c]);
            if (empties.length === 0) return false;
            const [r, c] = empties[Math.floor(Math.random() * empties.length)]; // ここでは、空のセルの中からランダムに1つ選んでいる
            g[r][c] = Math.random() < 0.9 ? 2 : 4;
            return { r, c };
        }

        /* グリッドを右に回転させる関数 */
        function rotateRight(g) {
            const out = createEmpty(); // outでは回転後のグリッドを作成

            for (let r = 0; r < SIZE; r++) for (let c = 0; c < SIZE; c++) out[c][SIZE - 1 - r] = g[r][c];
            return out;
        }
        function rotate(g, n) {
            let res = copyGrid(g); // resは回転後のグリッドを保持する変数で、最初は元のグリッドのコピーを代入している
            for (let i = 0; i < (n + 4) % 4; i++) res = rotateRight(res); 
            /* n + 4の理由は、負の回転を正の回転に変換するため
             例えば、-1回転は3回転と同じ意味になる
             (n + 4) % 4で0から3の範囲に収めている
             つまり、nが-3の場合でも1回転として扱えるようにしている
             これにより、rotate関数は左回転や下回転もサポートできるようになる
             */
            return res;
        }

        function moveLeft(g) { 
            const newG = createEmpty(); // newGは移動後のグリッドを保持する変数
            let moved = false, gain = 0; // movedは移動があったかどうか、gainは得点を保持する変数。最初falseの理由は、まだ移動が行われていないため
            for (let r = 0; r < SIZE; r++) {
                const line = g[r].filter(v => v !== 0); 
                // "v => v !== 0"は、0でない値だけを抽出するための条件
                // filterメソッドは、配列の各要素に対して指定した条件を満たす要素だけを抽出して新しい配列を作成するメソッド
                // 理解してない。。。。⭐️
                for (let i = 0; i < line.length - 1; i++) {
                    if (line[i] === line[i + 1]) {
                        line[i] *= 2;
                        gain += line[i];
                        line.splice(i + 1, 1);
                    }
                }
                for (let c = 0; c < line.length; c++) {
                    newG[r][c] = line[c]; //これは、line[c]の値をnewGの対応する位置に配置している
                    if (newG[r][c] !== g[r][c]) moved = true; // もし値が変わっていたら、movedをtrueに設定
                }
            }
            return { moved, gain, grid: newG }; //ここで、移動があったかどうか、得点、移動後のグリッドをオブジェクトとして返している
        }

        /* 移動可能かどうかを判定する関数 */
        function canMove(g) {
            for (let r = 0; r < SIZE; r++) 
                for (let c = 0; c < SIZE; c++) {
                    if (g[r][c] === 0) return true;
                    const v = g[r][c];
                    if (c + 1 < SIZE && g[r][c + 1] === v) return true;
                    if (r + 1 < SIZE && g[r + 1][c] === v) return true;
                }
            return false;
        }

        /* --- 描画（簡素） --- */
        function render() {
            boardEl.innerHTML = ''; // boardElとはゲーム盤の要素で、innerHTMLで中身を空にしている
            for (let r = 0; r < SIZE; r++) { //rは行で、rが0からSIZE-1までループ。SIZEは4なので、0から3まで。
                for (let c = 0; c < SIZE; c++) { // cは列で、cが0からSIZE-1までループ
                    const cell = document.createElement('div'); // cell要素を作成。div要素を作っている理由は、セルを表現するため
                    cell.className = 'cell'; //名前をcellに設定
                    const v = grid[r][c]; //ここでは、現在のグリッドの状態からセルの値を取得している
                    if (v !== 0) { // 値が0でない場合、つまりタイルが存在する場合
                        const tile = document.createElement('div'); // tile要素を作成。
                        tile.className = 'tile ' + 'v-' + v;
                        tile.textContent = v;
                        cell.appendChild(tile); //appendChildとは、指定した要素を子要素として追加するメソッド
                    }
                    boardEl.appendChild(cell);
                }
            }
            scoreEl.textContent = score;
            bestEl.textContent = best;
        }

        /* --- メイン移動関数 --- (dir:0=left,1=up,2=right,3=down) */
        function move(dir) {
            const rotated = rotate(grid, -dir); // dirに応じてグリッドを回転させる。-dirは反時計回りの回転を意味する
            const res = moveLeft(rotated); //resとは、回転後のグリッドに対して左移動を行った結果を保持する変数
            if (!res.moved) return false;
            const after = rotate(res.grid, dir);
            grid = after;
            score += res.gain;
            if (score > best) { best = score; localStorage.setItem('2048_best', best); }
            addRandomTile(grid);
            render();
            if (!canMove(grid)) setTimeout(() => alert('Game Over'), 30);
            return true;
        }

        /* --- 操作イベント --- */
        /* この部分では、キーボードの矢印キーやWASDキーでゲームを操作できるようにしている */
        window.addEventListener('keydown', (e) => {
            const key = e.key;
            let handled = false;
            if (['ArrowLeft', 'a', 'A'].includes(key)) handled = move(0);
            else if (['ArrowUp', 'w', 'W'].includes(key)) handled = move(1);
            else if (['ArrowRight', 'd', 'D'].includes(key)) handled = move(2);
            else if (['ArrowDown', 's', 'S'].includes(key)) handled = move(3);
            if (handled) e.preventDefault();
        });

        document.getElementById('btnNew').addEventListener('click', startNew);

        /* --- 新規ゲーム --- */
        function startNew() {
            grid = createEmpty();
            score = 0;
            addRandomTile(grid);
            addRandomTile(grid);
            render();
        }

        /* 初回開始 */
        startNew();
    </script>
</body>

</html>
